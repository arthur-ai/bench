{"id": "f5fb4d8d-1c18-42c8-b9ae-cc7b5bf22ec8", "name": "stack_dist_to_golden", "scoring_method": {"name": "bertscore", "type": "built_in", "config": {"precision_weight": 0.1, "recall_weight": 0.9, "model_type": "microsoft/deberta-v3-base"}}, "test_cases": [{"id": "ea436edf-cf19-44db-8a67-d5d7129ac16f", "input": "Why am I getting an UnboundLocalError when the variable has a value?", "reference_output": "\n It can be a surprise to get the UnboundLocalError in previously working\ncode when it is modified by adding an assignment statement somewhere in\nthe body of a function. \n This code: \n >>> x = 10\n>>> def bar():\n...     print(x)\n...\n>>> bar()\n10\n\n \n works, but this code: \n >>> x = 10\n>>> def foo():\n...     print(x)\n...     x += 1\n\n \n results in an UnboundLocalError: \n >>> foo()\nTraceback (most recent call last):\n  ...\nUnboundLocalError: local variable 'x' referenced before assignment\n\n \n This is because when you make an assignment to a variable"}, {"id": "d1032109-74e5-4efa-bff3-97e32aa5a096", "input": "What are the rules for local and global variables in Python?", "reference_output": "\n In Python, variables that are only referenced inside a function are implicitly\nglobal.  If a variable is assigned a value anywhere within the function\u2019s body,\nit\u2019s assumed to be a local unless explicitly declared as global. \n Though a bit surprising at first, a moment\u2019s consideration explains this.  On\none hand, requiring global for assigned variables provides a bar\nagainst unintended side-effects.  On the other hand, if global was required\nfor all global references, you\u2019d be using global all the time.  You\u2019d have\nto declare as global every reference to a built-in function or to a component of\nan imported module. "}, {"id": "65b6c961-89c9-4efd-97b1-f9b1bed29ef1", "input": "Why do lambdas defined in a loop with different values all return the same result?", "reference_output": "\n Assume you use a for loop to define a few different lambdas (or even plain\nfunctions), e.g.: \n >>> squares = []\n>>> for x in range(5):\n...     squares.append(lambda: x**2)\n\n \n This gives you a list that contains 5 lambdas that calculate x**2.  You\nmight expect that, when called, they would return, respectively, 0, 1,\n4, 9, and 16.  However, when you actually try you will see that\nthey all return 16: \n >>> squares[2]()\n16\n>>> squares[4]()\n16\n\n \n This happens because x is not local to the lambdas, but is defined in\nthe outer scope, and it is accessed when the"}, {"id": "20ae7739-08f8-4558-b87d-3a15af5fd32d", "input": "How do I share global variables across modules?", "reference_output": "\n The canonical way to share information across modules within a single program is\nto create a special module (often called config or cfg).  Just import the config\nmodule in all modules of your application; the module then becomes available as\na global name.  Because there is only one instance of each module, any changes\nmade to the module object get reflected everywhere.  For example: \n config.py: \n x = 0   # Default value of the 'x' configuration setting\n\n \n mod.py: \n import config\nconfig.x = 1\n\n \n main.py: \n import config\nimport mod\nprint(config.x)\n\n \n Note that using a module is"}, {"id": "f2367458-59ef-4232-96ba-447dd8beaaeb", "input": "What are the \u201cbest practices\u201d for using import in a module?", "reference_output": "\n In general, don\u2019t use from modulename import *.  Doing so clutters the\nimporter\u2019s namespace, and makes it much harder for linters to detect undefined\nnames. \n Import modules at the top of a file.  Doing so makes it clear what other modules\nyour code requires and avoids questions of whether the module name is in scope.\nUsing one import per line makes it easy to add and delete module imports, but\nusing multiple imports per line uses less screen space. \n It\u2019s good practice if you import modules in the following order: \n \nstandard library modules \u2013 e.g. sys, os, argparse, re\nthird-party"}, {"id": "f283c3d3-1fa1-43b4-b1e7-30c2d8491745", "input": "Why are default values shared between objects?", "reference_output": "\n This type of bug commonly bites neophyte programmers.  Consider this function: \n def foo(mydict={}):  # Danger: shared reference to one dict for all calls\n    ... compute something ...\n    mydict[key] = value\n    return mydict\n\n \n The first time you call this function, mydict contains a single item.  The\nsecond time, mydict contains two items because when foo() begins\nexecuting, mydict starts out with an item already in it. \n It is often expected that a function call creates new objects for default\nvalues. This is not what happens. Default values are"}, {"id": "054160b6-302e-487b-b008-8a8a6b60341f", "input": "How can I pass optional or keyword parameters from one function to another?", "reference_output": "\n Collect the arguments using the * and ** specifiers in the function\u2019s\nparameter list; this gives you the positional arguments as a tuple and the\nkeyword arguments as a dictionary.  You can then pass these arguments when\ncalling another function by using * and **: \n def f(x, *args, **kwargs):\n    ...\n    kwargs['width'] = '14.3c'\n    ...\n    g(x, *args, **kwargs)\n\n \n"}, {"id": "acd16195-8d64-444d-be21-aa951c2ce10e", "input": "What is the difference between arguments and parameters?", "reference_output": "\n Parameters are defined by the names that appear in a\nfunction definition, whereas arguments are the values\nactually passed to a function when calling it.  Parameters define what\nkind of arguments a function can accept.  For\nexample, given the function definition: \n def func(foo, bar=None, **kwargs):\n    pass\n\n \n foo, bar and kwargs are parameters of func.  However, when calling\nfunc, for example: \n func(42, bar=314, extra=somevar)\n\n \n the values 42, 314, and somevar are arguments. \n"}, {"id": "91668979-82e4-4893-8169-85ceab6a44d0", "input": "Why did changing list \u2018y\u2019 also change list \u2018x\u2019?", "reference_output": "\n If you wrote code like: \n >>> x = []\n>>> y = x\n>>> y.append(10)\n>>> y\n[10]\n>>> x\n[10]\n\n \n you might be wondering why appending an element to y changed x too. \n There are two factors that produce this result: \n \nVariables are simply names that refer to objects.  Doing y = x doesn\u2019t\ncreate a copy of the list \u2013 it creates a new variable y that refers to\nthe same object x refers to.  This means that there is only one object\n(the list), and both x and y refer to it.\nLists are mutable, which means that you can"}, {"id": "934c590c-a763-4838-8b84-c0e53c270563", "input": "How do I write a function with output parameters (call by reference)?", "reference_output": "\n Remember that arguments are passed by assignment in Python.  Since assignment\njust creates references to objects, there\u2019s no alias between an argument name in\nthe caller and callee, and so no call-by-reference per se.  You can achieve the\ndesired effect in a number of ways. \n \nBy returning a tuple of the results:\n>>> def func1(a, b):\n...     a = 'new-value'        # a and b are local names\n...     b = b + 1              #"}, {"id": "b35ffde1-96a5-4e0d-887d-6e36e701a199", "input": "How do you make a higher order function in Python?", "reference_output": "\n You have two choices: you can use nested scopes or you can use callable objects.\nFor example, suppose you wanted to define linear(a,b) which returns a\nfunction f(x) that computes the value a*x+b.  Using nested scopes: \n def linear(a, b):\n    def result(x):\n        return a * x + b\n    return result\n\n \n Or using a callable object: \n class linear:\n\n    def __init__(self, a, b):\n        self.a, self.b = a, b\n\n    def __call__(self, x):\n   "}, {"id": "e174681b-f3a8-47f1-89bf-a79afff77928", "input": "How do I copy an object in Python?", "reference_output": "\n In general, try copy.copy() or copy.deepcopy() for the general case.\nNot all objects can be copied, but most can. \n Some objects can be copied more easily.  Dictionaries have a copy()\nmethod: \n newdict = olddict.copy()\n\n \n Sequences can be copied by slicing: \n new_l = l[:]\n\n \n"}, {"id": "4e2a7372-dcce-4361-a89a-fbc26c5c6c17", "input": "How can I find the methods or attributes of an object?", "reference_output": "\n For an instance x of a user-defined class, dir(x) returns an alphabetized\nlist of the names containing the instance attributes and methods and attributes\ndefined by its class. \n"}, {"id": "331b9a3b-b60a-4e2f-853e-d6af9272b626", "input": "How can my code discover the name of an object?", "reference_output": "\n Generally speaking, it can\u2019t, because objects don\u2019t really have names.\nEssentially, assignment always binds a name to a value; the same is true of\ndef and class statements, but in that case the value is a\ncallable. Consider the following code: \n >>> class A:\n...     pass\n...\n>>> B = A\n>>> a = B()\n>>> b = a\n>>> print(b)\n<__main__.A object at 0x16D07CC>\n>>> print(a)\n<__main__.A object at 0x16D07CC>\n\n \n Arguably the class has a name: even though it is bound to two names and invoked\nthrough the name B the created instance is still reported as an instance of\nclass A.  However, it is"}, {"id": "6cf7051d-0428-4195-8b49-22b39c9422bb", "input": "What\u2019s up with the comma operator\u2019s precedence?", "reference_output": "\n Comma is not an operator in Python.  Consider this session: \n >>> \"a\" in \"b\", \"a\"\n(False, 'a')\n\n \n Since the comma is not an operator, but a separator between expressions the\nabove is evaluated as if you had entered: \n (\"a\" in \"b\"), \"a\"\n\n \n not: \n \"a\" in (\"b\", \"a\")\n\n \n The same is true of the various assignment operators (=, += etc).  They\nare not truly operators but syntactic delimiters in assignment statements. \n"}, {"id": "9781e90e-a96b-4c98-98f3-975b24d1be3d", "input": "Is there an equivalent of C\u2019s \u201c?:\u201d ternary operator?", "reference_output": "\n Yes, there is. The syntax is as follows: \n [on_true] if [expression] else [on_false]\n\nx, y = 50, 25\nsmall = x if x < y else y\n\n \n Before this syntax was introduced in Python 2.5, a common idiom was to use\nlogical operators: \n [expression] and [on_true] or [on_false]\n\n \n However, this idiom is unsafe, as it can give wrong results when on_true\nhas a false boolean value.  Therefore, it is always better to use\nthe ... if ... else ... form. \n"}, {"id": "39de7c85-d19a-4166-a4a4-d3228bcdbc1e", "input": "Is it possible to write obfuscated one-liners in Python?", "reference_output": "\n Yes.  Usually this is done by nesting lambda within\nlambda.  See the following three examples, slightly adapted from Ulf Bartelt: \n from functools import reduce\n\n# Primes < 1000\nprint(list(filter(None,map(lambda y:y*reduce(lambda x,y:x*y!=0,\nmap(lambda x,y=y:y%x,range(2,int(pow(y,0.5)+1))),1),range(2,1000)))))\n\n# First 10 Fibonacci numbers\nprint(list(map(lambda x,f=lambda x,f:(f(x-1,f)+f(x-2,f)) if x>1 else 1:\nf(x,f), range(10))))\n\n# Mandelbrot set\nprint((lambda Ru,Ro,Iu,Io,IM,Sx,Sy:reduce(lambda x,y:x+'\\n'+y,map(lambda y,\nIu=Iu,Io=Io,Ru=Ru,Ro=Ro,Sy=Sy,L=lambda yc,Iu=Iu,Io=Io,Ru=Ru,Ro=Ro,i=IM,\nSx=Sx,Sy=Sy:reduce(lambda x,y:x+y,map(lambda x,xc=Ru,yc=yc,Ru=Ru,Ro=Ro,\ni=i,Sx=Sx,F=lambda xc,yc,x,y,k,f=lambda xc,yc,x,y,k,f:(k<=0)or (x*x+y*y\n>=4.0) or 1+f(xc,yc,x*x-y*y+xc,2.0*x*y+yc,k-1,f):f(xc,yc,x,y,k,f):chr(\n64+F(Ru+x*(Ro-Ru)/Sx,yc,0,0,i)),range(Sx))):L(Iu+y*(Io-Iu)/Sy),range(Sy\n))))(-2.1, 0.7, -1.2, 1.2, 30, 80, 24))\n#    \\___ ___/  \\___ ___/  |   |   |__ lines on screen\n#        V          V"}, {"id": "34cadfb3-8aaa-4bec-acca-7ac37a4ac020", "input": "What does the slash(/) in the parameter list of a function mean?", "reference_output": "\n A slash in the argument list of a function denotes that the parameters prior to\nit are positional-only.  Positional-only parameters are the ones without an\nexternally usable name.  Upon calling a function that accepts positional-only\nparameters, arguments are mapped to parameters based solely on their position.\nFor example, divmod() is a function that accepts positional-only\nparameters. Its documentation looks like this: \n >>> help(divmod)\nHelp on built-in function divmod in module builtins:\n\ndivmod(x, y, /)\n    Return the tuple (x//y, x%y).  Invariant: div*y + mod == x.\n\n \n The slash at the end of the parameter list means that both parameters"}, {"id": "e6ef7d07-017b-46b1-ab5a-b59bffedbb65", "input": "How do I specify hexadecimal and octal integers?", "reference_output": "\n To specify an octal digit, precede the octal value with a zero, and then a lower\nor uppercase \u201co\u201d.  For example, to set the variable \u201ca\u201d to the octal value \u201c10\u201d\n(8 in decimal), type: \n >>> a = 0o10\n>>> a\n8\n\n \n Hexadecimal is just as easy.  Simply precede the hexadecimal number with a zero,\nand then a lower or uppercase \u201cx\u201d.  Hexadecimal digits can be specified in lower\nor uppercase.  For example, in the Python interpreter: \n >>> a = 0xa5\n>>> a\n165\n>>> b = 0XB2\n>>> b\n178\n\n \n"}, {"id": "19c6847d-befa-4061-b2b2-31bf9adf51d9", "input": "Why does -22 // 10 return -3?", "reference_output": "\n It\u2019s primarily driven by the desire that i % j have the same sign as j.\nIf you want that, and also want: \n i == (i // j) * j + (i % j)\n\n \n then integer division has to return the floor.  C also requires that identity to\nhold, and then compilers that truncate i // j need to make i % j have\nthe same sign as i. \n There are few real use cases for i % j when j is negative.  When j\nis positive, there are many, and in virtually all of them it\u2019s more"}, {"id": "e1d6253e-b035-4566-8176-685e9ef5c46d", "input": "How do I get int literal attribute instead of SyntaxError?", "reference_output": "\n Trying to lookup an int literal attribute in the normal manner gives\na SyntaxError because the period is seen as a decimal point: \n >>> 1.__class__\n  File \"<stdin>\", line 1\n  1.__class__\n   ^\nSyntaxError: invalid decimal literal\n\n \n The solution is to separate the literal from the period\nwith either a space or parentheses. \n >>> 1 .__class__\n<class 'int'>\n>>> (1).__class__\n<class 'int'>\n\n \n"}, {"id": "bb4167d9-5fe4-4c00-b4bb-9cfe16378fa1", "input": "How do I convert a string to a number?", "reference_output": "\n For integers, use the built-in int() type constructor, e.g. int('144')\n== 144.  Similarly, float() converts to floating-point,\ne.g. float('144') == 144.0. \n By default, these interpret the number as decimal, so that int('0144') ==\n144 holds true, and int('0x144') raises ValueError. int(string,\nbase) takes the base to convert from as a second optional argument, so int(\n'0x144', 16) == 324.  If the base is specified as 0, the number is interpreted\nusing Python\u2019s rules: a leading \u20180o\u2019 indicates octal, and \u20180x\u2019 indicates a hex\nnumber. \n Do not use the built-in function eval() if all you need is to convert\nstrings to numbers.  eval()"}, {"id": "2e4144e9-89c2-4abf-bd86-20f9e16d45f8", "input": "How do I convert a number to a string?", "reference_output": "\n To convert, e.g., the number 144 to the string '144', use the built-in type\nconstructor str().  If you want a hexadecimal or octal representation, use\nthe built-in functions hex() or oct().  For fancy formatting, see\nthe Formatted string literals and Format String Syntax sections,\ne.g. \"{:04d}\".format(144) yields\n'0144' and \"{:.3f}\".format(1.0/3.0) yields '0.333'. \n"}, {"id": "ecbaab76-c11e-4d9e-bdc0-75de1d1e46b6", "input": "How do I modify a string in place?", "reference_output": "\n You can\u2019t, because strings are immutable.  In most situations, you should\nsimply construct a new string from the various parts you want to assemble\nit from.  However, if you need an object with the ability to modify in-place\nunicode data, try using an io.StringIO object or the array\nmodule: \n >>> import io\n>>> s = \"Hello, world\"\n>>> sio = io.StringIO(s)\n>>> sio.getvalue()\n'Hello, world'\n>>> sio.seek(7)\n7\n>>> sio.write(\"there!\")\n6\n>>> sio.getvalue()\n'Hello, there!'\n\n>>> import array\n>>> a = array.array('u', s)\n>>> print(a)\narray('u', 'Hello, world')\n>>> a[0] = 'y'\n>>> print(a)\narray('u', 'yello, world')\n>>> a.tounicode()\n'yello, world'\n\n \n"}, {"id": "0ae164c6-70b5-49ed-bc03-996fc3548c72", "input": "How do I use strings to call functions/methods?", "reference_output": "\n There are various techniques. \n \nThe best is to use a dictionary that maps strings to functions.  The primary\nadvantage of this technique is that the strings do not need to match the names\nof the functions.  This is also the primary technique used to emulate a case\nconstruct:\ndef a():\n    pass\n\ndef b():\n    pass\n\ndispatch = {'go': a, 'stop': b}  # Note lack of parens for funcs\n\ndispatch[get_input()]()  # Note trailing parens to call function\n\n\n\nUse the built-in function getattr():\nimport foo\ngetattr(foo, 'bar')()\n\n\nNote that getattr() works on any object, including classes, class\ninstances, modules, and so on.\nThis is"}, {"id": "f29c68c8-1b2f-4437-9840-881c12e65b10", "input": "Is there an equivalent to Perl\u2019s chomp() for removing trailing newlines from strings?", "reference_output": "\n You can use S.rstrip(\"\\r\\n\") to remove all occurrences of any line\nterminator from the end of the string S without removing other trailing\nwhitespace.  If the string S represents more than one line, with several\nempty lines at the end, the line terminators for all the blank lines will\nbe removed: \n >>> lines = (\"line 1 \\r\\n\"\n...          \"\\r\\n\"\n...          \"\\r\\n\")\n>>> lines.rstrip(\"\\n\\r\")\n'line 1 '\n\n \n Since this is typically only desired when reading text one line at a time, using\nS.rstrip() this way works well. \n"}, {"id": "dfb00606-e86b-4f1d-b287-5f9682ac27b0", "input": "Is there a scanf() or sscanf() equivalent?", "reference_output": "\n Not as such. \n For simple input parsing, the easiest approach is usually to split the line into\nwhitespace-delimited words using the split() method of string objects\nand then convert decimal strings to numeric values using int() or\nfloat().  split() supports an optional \u201csep\u201d parameter which is useful\nif the line uses something other than whitespace as a separator. \n For more complicated input parsing, regular expressions are more powerful\nthan C\u2019s sscanf and better suited for the task. \n"}, {"id": "37d479ef-0729-47cc-8d49-ee726f4dcf53", "input": "What does \u2018UnicodeDecodeError\u2019 or \u2018UnicodeEncodeError\u2019 error  mean?", "reference_output": "\n See the Unicode HOWTO. \n"}, {"id": "63f18cd5-f7ae-4225-9f28-9c54f4a3ba5c", "input": "Can I end a raw string with an odd number of backslashes?", "reference_output": "\n A raw string ending with an odd number of backslashes will escape the string\u2019s quote: \n >>> r'C:\\this\\will\\not\\work\\'\n  File \"<stdin>\", line 1\n    r'C:\\this\\will\\not\\work\\'\n         ^\nSyntaxError: unterminated string literal (detected at line 1)\n\n \n There are several workarounds for this. One is to use regular strings and double\nthe backslashes: \n >>> 'C:\\\\this\\\\will\\\\work\\\\'\n'C:\\\\this\\\\will\\\\work\\\\'\n\n \n Another is to concatenate a regular string containing an escaped backslash to the\nraw string: \n >>> r'C:\\this\\will\\work' '\\\\'\n'C:\\\\this\\\\will\\\\work\\\\'\n\n \n It is also possible to use os.path.join() to append a backslash on Windows: \n >>> os.path.join(r'C:\\this\\will\\work', '')\n'C:\\\\this\\\\will\\\\work\\\\'\n\n"}, {"id": "6323d4fe-a8f7-4bdd-bff1-06845213be45", "input": "My program is too slow. How do I speed it up?", "reference_output": "\n That\u2019s a tough one, in general.  First, here are a list of things to\nremember before diving further: \n \nPerformance characteristics vary across Python implementations.  This FAQ\nfocuses on CPython.\nBehaviour can vary across operating systems, especially when talking about\nI/O or multi-threading.\nYou should always find the hot spots in your program before attempting to\noptimize any code (see the profile module).\nWriting benchmark scripts will allow you to iterate quickly when searching\nfor improvements (see the timeit module).\nIt is highly recommended to have good code coverage (through unit testing\nor any other technique) before potentially introducing regressions hidden\nin sophisticated optimizations.\n \n That being said,"}, {"id": "1ddc9963-6fa2-4187-afd1-6be9e8ffe421", "input": "What is the most efficient way to concatenate many strings together?", "reference_output": "\n str and bytes objects are immutable, therefore concatenating\nmany strings together is inefficient as each concatenation creates a new\nobject.  In the general case, the total runtime cost is quadratic in the\ntotal string length. \n To accumulate many str objects, the recommended idiom is to place\nthem into a list and call str.join() at the end: \n chunks = []\nfor s in my_strings:\n    chunks.append(s)\nresult = ''.join(chunks)\n\n \n (another reasonably efficient idiom is to use io.StringIO) \n To accumulate many bytes objects, the recommended idiom is to extend\na bytearray object using in-place concatenation (the += operator): \n result ="}, {"id": "502dc2e1-c48d-4f1e-8ce1-7b7a37d6af9c", "input": "How do I convert between tuples and lists?", "reference_output": "\n The type constructor tuple(seq) converts any sequence (actually, any\niterable) into a tuple with the same items in the same order. \n For example, tuple([1, 2, 3]) yields (1, 2, 3) and tuple('abc')\nyields ('a', 'b', 'c').  If the argument is a tuple, it does not make a copy\nbut returns the same object, so it is cheap to call tuple() when you\naren\u2019t sure that an object is already a tuple. \n The type constructor list(seq) converts any sequence or iterable into a list\nwith the same items in the same order.  For example, list((1, 2, 3)) yields\n[1, 2, 3] and"}, {"id": "cf79a434-d950-4aea-aaa6-58a4fb7fc8b8", "input": "What\u2019s a negative index?", "reference_output": "\n Python sequences are indexed with positive numbers and negative numbers.  For\npositive numbers 0 is the first index 1 is the second index and so forth.  For\nnegative indices -1 is the last index and -2 is the penultimate (next to last)\nindex and so forth.  Think of seq[-n] as the same as seq[len(seq)-n]. \n Using negative indices can be very convenient.  For example S[:-1] is all of\nthe string except for its last character, which is useful for removing the\ntrailing newline from a string. \n"}, {"id": "e25f997f-934f-4faa-b4ba-90fcf2b6d705", "input": "How do I iterate over a sequence in reverse order?", "reference_output": "\n Use the reversed() built-in function: \n for x in reversed(sequence):\n    ...  # do something with x ...\n\n \n This won\u2019t touch your original sequence, but build a new copy with reversed\norder to iterate over. \n"}, {"id": "826c2161-eecd-487f-91ae-a8c1ca43d090", "input": "How do you remove duplicates from a list?", "reference_output": "\n See the Python Cookbook for a long discussion of many ways to do this: \n \nhttps://code.activestate.com/recipes/52560/\n \n If you don\u2019t mind reordering the list, sort it and then scan from the end of the\nlist, deleting duplicates as you go: \n if mylist:\n    mylist.sort()\n    last = mylist[-1]\n    for i in range(len(mylist)-2, -1, -1):\n        if last == mylist[i]:\n            del mylist[i]\n        else:\n      "}, {"id": "e5ea95c2-58dd-4a80-8cea-cf1fda6fe262", "input": "How do you remove multiple items from a list", "reference_output": "\n As with removing duplicates, explicitly iterating in reverse with a\ndelete condition is one possibility.  However, it is easier and faster\nto use slice replacement with an implicit or explicit forward iteration.\nHere are three variations.: \n mylist[:] = filter(keep_function, mylist)\nmylist[:] = (x for x in mylist if keep_condition)\nmylist[:] = [x for x in mylist if keep_condition]\n\n \n The list comprehension may be fastest. \n"}, {"id": "98f182f4-a91c-4b2b-a80b-d33b1cf20a87", "input": "How do you make an array in Python?", "reference_output": "\n Use a list: \n [\"this\", 1, \"is\", \"an\", \"array\"]\n\n \n Lists are equivalent to C or Pascal arrays in their time complexity; the primary\ndifference is that a Python list can contain objects of many different types. \n The array module also provides methods for creating arrays of fixed types\nwith compact representations, but they are slower to index than lists.  Also\nnote that NumPy\nand other third party packages define array-like structures with\nvarious characteristics as well. \n To get Lisp-style linked lists, you can emulate cons cells using tuples: \n lisp_list = (\"like\",  (\"this\",  (\"example\", None) ) )\n\n \n"}, {"id": "e73380bb-9f21-4dc7-aa84-633a765973f5", "input": "How do I create a multidimensional list?", "reference_output": "\n You probably tried to make a multidimensional array like this: \n >>> A = [[None] * 2] * 3\n\n \n This looks correct if you print it: \n >>> A\n[[None, None], [None, None], [None, None]]\n\n \n But when you assign a value, it shows up in multiple places: \n >>> A[0][0] = 5\n>>> A\n[[5, None], [5, None], [5, None]]\n\n \n The reason is that replicating a list with * doesn\u2019t create copies, it only\ncreates references to the existing objects.  The *3 creates a list\ncontaining 3 references to the same list of length two.  Changes to one row"}, {"id": "5e06ae41-422d-4280-9ca4-faf66628c9fd", "input": "How do I apply a method or function to a sequence of objects?", "reference_output": "\n To call a method or function and accumulate the return values is a list,\na list comprehension is an elegant solution: \n result = [obj.method() for obj in mylist]\n\nresult = [function(obj) for obj in mylist]\n\n \n To just run the method or function without saving the return values,\na plain for loop will suffice: \n for obj in mylist:\n    obj.method()\n\nfor obj in mylist:\n    function(obj)\n\n \n"}, {"id": "87ebdf3c-74b5-4ce9-918b-dffdbd2ad393", "input": "Why does a_tuple[i] += [\u2018item\u2019] raise an exception when the addition works?", "reference_output": "\n This is because of a combination of the fact that augmented assignment\noperators are assignment operators, and the difference between mutable and\nimmutable objects in Python. \n This discussion applies in general when augmented assignment operators are\napplied to elements of a tuple that point to mutable objects, but we\u2019ll use\na list and += as our exemplar. \n If you wrote: \n >>> a_tuple = (1, 2)\n>>> a_tuple[0] += 1\nTraceback (most recent call last):\n   ...\nTypeError: 'tuple' object does not support item assignment\n\n \n The reason for the exception should be immediately clear: 1 is added to the\nobject a_tuple[0] points to"}, {"id": "b8570452-69ef-4fd9-980b-a9828f40f7f1", "input": "I want to do a complicated sort: can you do a Schwartzian Transform in Python?", "reference_output": "\n The technique, attributed to Randal Schwartz of the Perl community, sorts the\nelements of a list by a metric which maps each element to its \u201csort value\u201d. In\nPython, use the key argument for the list.sort() method: \n Isorted = L[:]\nIsorted.sort(key=lambda s: int(s[10:15]))\n\n \n"}, {"id": "1c5c2cf2-5ad6-49cc-9096-1a600dbd4617", "input": "How can I sort one list by values from another list?", "reference_output": "\n Merge them into an iterator of tuples, sort the resulting list, and then pick\nout the element you want. \n >>> list1 = [\"what\", \"I'm\", \"sorting\", \"by\"]\n>>> list2 = [\"something\", \"else\", \"to\", \"sort\"]\n>>> pairs = zip(list1, list2)\n>>> pairs = sorted(pairs)\n>>> pairs\n[(\"I'm\", 'else'), ('by', 'sort'), ('sorting', 'to'), ('what', 'something')]\n>>> result = [x[1] for x in pairs]\n>>> result\n['else', 'sort', 'to', 'something']\n\n \n"}, {"id": "d4ddd998-8940-4792-a9d9-7dd7122c5a01", "input": "What is a class?", "reference_output": "\n A class is the particular object type created by executing a class statement.\nClass objects are used as templates to create instance objects, which embody\nboth the data (attributes) and code (methods) specific to a datatype. \n A class can be based on one or more other classes, called its base class(es). It\nthen inherits the attributes and methods of its base classes. This allows an\nobject model to be successively refined by inheritance.  You might have a\ngeneric Mailbox class that provides basic accessor methods for a mailbox,\nand subclasses such as MboxMailbox, MaildirMailbox, OutlookMailbox\nthat handle various specific mailbox formats. \n"}, {"id": "901ab81b-62b0-4b09-8ad8-c59b5b6f1747", "input": "What is a method?", "reference_output": "\n A method is a function on some object x that you normally call as\nx.name(arguments...).  Methods are defined as functions inside the class\ndefinition: \n class C:\n    def meth(self, arg):\n        return arg * 2 + self.attribute\n\n \n"}, {"id": "0dc41b5d-fe3a-475e-b024-47cc673a2b28", "input": "What is self?", "reference_output": "\n Self is merely a conventional name for the first argument of a method.  A method\ndefined as meth(self, a, b, c) should be called as x.meth(a, b, c) for\nsome instance x of the class in which the definition occurs; the called\nmethod will think it is called as meth(x, a, b, c). \n See also Why must \u2018self\u2019 be used explicitly in method definitions and calls?. \n"}, {"id": "f6f0dfb6-f35b-4657-80ca-ff7dd206e42d", "input": "How do I check if an object is an instance of a given class or of a subclass of it?", "reference_output": "\n Use the built-in function isinstance(obj, cls).  You can\ncheck if an object\nis an instance of any of a number of classes by providing a tuple instead of a\nsingle class, e.g. isinstance(obj, (class1, class2, ...)), and can also\ncheck whether an object is one of Python\u2019s built-in types, e.g.\nisinstance(obj, str) or isinstance(obj, (int, float, complex)). \n Note that isinstance() also checks for virtual inheritance from an\nabstract base class.  So, the test will return True for a\nregistered class even if hasn\u2019t directly or indirectly inherited from it.  To\ntest for \u201ctrue inheritance\u201d, scan the MRO of the class: \n from collections.abc"}, {"id": "2e0e5057-5a29-48de-9370-453331c5005b", "input": "What is delegation?", "reference_output": "\n Delegation is an object oriented technique (also called a design pattern).\nLet\u2019s say you have an object x and want to change the behaviour of just one\nof its methods.  You can create a new class that provides a new implementation\nof the method you\u2019re interested in changing and delegates all other methods to\nthe corresponding method of x. \n Python programmers can easily implement delegation.  For example, the following\nclass implements a class that behaves like a file but converts all written data\nto uppercase: \n class UpperOut:\n\n    def __init__(self, outfile):\n        self._outfile"}, {"id": "4c137794-3434-499e-be6e-e0bf1ea5667b", "input": "How do I call a method defined in a base class from a derived class that extends it?", "reference_output": "\n Use the built-in super() function: \n class Derived(Base):\n    def meth(self):\n        super().meth()  # calls Base.meth\n\n \n In the example, super() will automatically determine the instance from\nwhich it was called (the self value), look up the method resolution\norder (MRO) with type(self).__mro__, and return the next in line after\nDerived in the MRO: Base. \n"}, {"id": "1b7f680a-40a6-4f62-b123-f054156f514f", "input": "How can I organize my code to make it easier to change the base class?", "reference_output": "\n You could assign the base class to an alias and derive from the alias.  Then all\nyou have to change is the value assigned to the alias.  Incidentally, this trick\nis also handy if you want to decide dynamically (e.g. depending on availability\nof resources) which base class to use.  Example: \n class Base:\n    ...\n\nBaseAlias = Base\n\nclass Derived(BaseAlias):\n    ...\n\n \n"}, {"id": "0fda86a6-ed8f-4ff1-83b3-363c08a2fa1f", "input": "How do I create static class data and static class methods?", "reference_output": "\n Both static data and static methods (in the sense of C++ or Java) are supported\nin Python. \n For static data, simply define a class attribute.  To assign a new value to the\nattribute, you have to explicitly use the class name in the assignment: \n class C:\n    count = 0   # number of times C.__init__ called\n\n    def __init__(self):\n        C.count = C.count + 1\n\n    def getcount(self):\n        return C.count  # or return self.count\n\n \n c.count"}, {"id": "0c32dc25-1c8f-4cda-a1fc-4af54273793e", "input": "How can I overload constructors (or methods) in Python?", "reference_output": "\n This answer actually applies to all methods, but the question usually comes up\nfirst in the context of constructors. \n In C++ you\u2019d write \n class C {\n    C() { cout << \"No arguments\\n\"; }\n    C(int i) { cout << \"Argument is \" << i << \"\\n\"; }\n}\n\n \n In Python you have to write a single constructor that catches all cases using\ndefault arguments.  For example: \n class C:\n    def __init__(self, i=None):\n        if i is None:\n       "}, {"id": "05d7457a-7991-4fb2-bc1e-96fb4e943ad9", "input": "I try to use __spam and I get an error about _SomeClassName__spam.", "reference_output": "\n Variable names with double leading underscores are \u201cmangled\u201d to provide a simple\nbut effective way to define class private variables.  Any identifier of the form\n__spam (at least two leading underscores, at most one trailing underscore)\nis textually replaced with _classname__spam, where classname is the\ncurrent class name with any leading underscores stripped. \n This doesn\u2019t guarantee privacy: an outside user can still deliberately access\nthe \u201c_classname__spam\u201d attribute, and private values are visible in the object\u2019s\n__dict__.  Many Python programmers never bother to use private variable\nnames at all. \n"}, {"id": "484000b3-fbad-4a66-9dff-cf4154239846", "input": "My class defines __del__ but it is not called when I delete the object.", "reference_output": "\n There are several possible reasons for this. \n The del statement does not necessarily call __del__() \u2013 it simply\ndecrements the object\u2019s reference count, and if this reaches zero\n__del__() is called. \n If your data structures contain circular links (e.g. a tree where each child has\na parent reference and each parent has a list of children) the reference counts\nwill never go back to zero.  Once in a while Python runs an algorithm to detect\nsuch cycles, but the garbage collector might run some time after the last\nreference to your data structure vanishes, so your __del__() method may be\ncalled at an"}, {"id": "d5387094-a495-47df-8a1b-5ad01258e232", "input": "How do I get a list of all instances of a given class?", "reference_output": "\n Python does not keep track of all instances of a class (or of a built-in type).\nYou can program the class\u2019s constructor to keep track of all instances by\nkeeping a list of weak references to each instance. \n"}, {"id": "19aa94d9-7f0e-4283-80d0-c2c2657ef90c", "input": "Why does the result of id() appear to be not unique?", "reference_output": "\n The id() builtin returns an integer that is guaranteed to be unique during\nthe lifetime of the object.  Since in CPython, this is the object\u2019s memory\naddress, it happens frequently that after an object is deleted from memory, the\nnext freshly created object is allocated at the same position in memory.  This\nis illustrated by this example: \n >>> id(1000) \n13901272\n>>> id(2000) \n13901272\n\n \n The two ids belong to different integer objects that are created before, and\ndeleted immediately after execution of the id() call.  To be sure that\nobjects whose id you want to examine are still alive, create another reference\nto"}, {"id": "813b61d8-826f-4a6f-9ed8-f5436f1d8412", "input": "When can I rely on identity tests with the is operator?", "reference_output": "\n The is operator tests for object identity.  The test a is b is\nequivalent to id(a) == id(b). \n The most important property of an identity test is that an object is always\nidentical to itself, a is a always returns True.  Identity tests are\nusually faster than equality tests.  And unlike equality tests, identity tests\nare guaranteed to return a boolean True or False. \n However, identity tests can only be substituted for equality tests when\nobject identity is assured.  Generally, there are three circumstances where\nidentity is guaranteed: \n 1) Assignments create new names but do not change object"}, {"id": "74e08d26-3d6e-4ea6-a031-a7de1a5e11ba", "input": "How can a subclass control what data is stored in an immutable instance?", "reference_output": "\n When subclassing an immutable type, override the __new__() method\ninstead of the __init__() method.  The latter only runs after an\ninstance is created, which is too late to alter data in an immutable\ninstance. \n All of these immutable classes have a different signature than their\nparent class: \n from datetime import date\n\nclass FirstOfMonthDate(date):\n    \"Always choose the first day of the month\"\n    def __new__(cls, year, month, day):\n        return super().__new__(cls, year, month, 1)\n\nclass NamedInt(int):\n    \"Allow text names for some numbers\"\n    xlat = {'zero': 0,"}, {"id": "67b42790-db82-4d92-8e4a-d054f5147a07", "input": "How do I cache method calls?", "reference_output": "\n The two principal tools for caching methods are\nfunctools.cached_property() and functools.lru_cache().  The\nformer stores results at the instance level and the latter at the class\nlevel. \n The cached_property approach only works with methods that do not take\nany arguments.  It does not create a reference to the instance.  The\ncached method result will be kept only as long as the instance is alive. \n The advantage is that when an instance is no longer used, the cached\nmethod result will be released right away.  The disadvantage is that if\ninstances accumulate, so too will the accumulated method results.  They\ncan grow"}], "created_at": "2023-08-14T21:32:22.882016", "updated_at": "2023-08-14T21:32:22.882016", "description": null, "last_run_time": "2023-08-14T21:33:21.730187", "num_runs": 2, "page": null, "page_size": null, "total_pages": null, "total_count": null}
